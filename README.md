# Namica
This is 2D Geme engine.

## 构建项目
* 三方依赖位置: <a href='https://github.com/qihaichiaki/Namica/releases/tag/ThirdParty'>ThirdParty</a>
* 将thirdparty文件解压放置在Namica文件目录下, 使用cmake即可构建本项目(可以使用本地脚本FetchThirdparty进行拉取(注意由于是github, 可以使用(-UseProxy -ProxyPort xxxx)设置当前系统代理进行拉取, 详细请看脚本))
* 后续会添加resources包, 请根据tag选择添加
* 三方依赖清单：imgui、SDL2、SDL2_image、SDL2_gfx、SDL2_mixer、SDL2_ttf、cJson、EasyX、lua、pugixml


## 应用程序
### 前言
在当前的设计构想中, 存在editor和runtime两个运行时概念. 另外为了抽象应用程序框架(方便后续扩展更多的应用框架底层)， 所以简单的设计了一套抽象的应用程序体系，后续无论是具体实现的editor(imgui + sdl2)， 还是单独的runtime(sdl2)，直接继承实现对应的方法即可, 随后外界只需要调用相关基类方法(无法重写的, 固定调用实现重写的方法流程)即可跑通应用。
### 流程
1. 初始化 - init
初始化阶段，会对需要使用资源、渲染、窗口等各个子系统进行初始化, 并且可能存在各个管理器, 固定初始化其流程。
2. 当前帧前处理 - beginFrame
进入循环阶段,程序处理的时候均是基于当前帧状态进行,因为是实时应用程序. 在当前帧进入前的处理均可在此实现。
3. 事件处理 - processEvents
在循环阶段中, 需要处理来自用户输入的各种事件, 在此即可进行处理。
4. 逻辑更新 - update
涉及应用程序逻辑更新的处理阶段, 可以进行逻辑、物理更新.
5. 渲染 - render
需要将更新后的画面渲染到屏幕上，可以在此处处理渲染
6. 当前帧后处理 - endFrame
在循环阶段的当前帧将要结束时可在此处理
7. 释放 - drop
应用程序结束，需要释放资源阶段
### editor/runtime app
编辑器应用程序,当前阶段是imgui+sdl2的组合.运行时应用程序, 是纯SDL2.目前希望的是, 在editor_app能够包含到runtime_app，另外runtime_app也能作为一个独立的个体单独运行。
#### 整体思路
1. 编辑器应用程序, 会初始化renderer, 然后将其传入runtime_app，让两个之后会共享一个renderer?
2. 编辑器基本是初始化imgui相关，runtime_app是初始化sdl相关(两者之间会整合在一起, 完整的初始化整个应用框架)

## 公共依赖实例
基本上是引擎/游戏运行时能够获取的上下文的信息, 设计成单例, 方便全局获取。
### Time-时间管理器
1. FPS设置与获取
设置过程中，方便计算帧间隔时间, 为后续的每帧运行时间做准备
2. Delta帧间隔时间
可以获取当前帧和前一帧的时间差，方便用于进行逻辑更新, 并且用户可以随意设置时间的相关缩放, 从而达到时间静止的效果
3. 在应用程序框架中
可以借此设置每帧的帧间隔时间，并且将多余出来的时间让cpu将时间片放出，节省cpu资源


## 资源系统
### 前言
* 游戏包含引擎自然需要各种外部资源：纹理图片、音频、字体......但是它们都是保存在硬盘上的，需要读取到内存中去应用。
* 既然需要读取，那么就需要根据对应的类型存储对应的数据。由于不同的渲染引擎处理的数据格式可能会不同，首先就需要将资源类型抽象化，将具体的渲染数据封装
* 资源放置在指定的目录下，由引擎统一加载处理。并且每份资源根据其路径的唯一性（ID），对应唯一的一份资源，在游戏进程中都是对此资源持有引用
* Namica想要达到的目标: 1. 在编码层面抽象资源对象一层，底层可以封装不同库的资源类型，对上层保持一致(比如底层可以是SDL的相关资源类型, 也可以是EasyX相关的资源类型)。2. 完成引擎的资源目录管理, 能热更新资源, 存在虚拟文件目录，能拖拽到上面去.


### 资源类型
#### 图像Image
* 通常表现为图片，硬盘中保存的格式为:.png/.jpg, 其中.png是可以带透明度的(也是游戏开发中常用的素材类型)
* 类型：Image
* 描述：图像解码在内存中的数据存储。
* 抽象实现：因为底层可能存在不同的渲染、数据存储（当前阶段是SDL/easyX），所以Image是一个基类，不同的渲染数据实现继承自基类。针对于渲染时, 由于渲染也是抽象出来的，那么不同的渲染层拿到对应的渲染数据即可直接使用。
* 公共方法/属性：
  1. 纹理资源的固有属性：宽/高（不可更改）

* 具体实现：
  * SDL_Texture* ，通过SDLTexture工厂类创建出即可(初始化SDLRenderer)

#### 音频Audio
* 硬盘中的保存格式为：.mp3 .wav ... 其中常见的情况下，mp3适用于音乐播放，wav适用于音效播放
* 类型: Audio
* 描述：1.在资源载入阶段，即引擎编辑阶段，大多数只是预览声音，所以引擎加载为Music即可 2. 用户选择阶段，用户可以根据实际的业务场景，选择加载音频的类型（Music、Chunk）。其中Music是流式加载播放，适合bgm(需要注意特性，每时每刻只能存在一个music播放)，Chunk非流式播放，适合音效播放，并且支持多音频通道播放
* 抽象实现：Audio为基类，不同的音频数据继承自Audio实现，只提供数据，不提供行为
* 具体实现：
  * Mix_Music* Mix_Chunk*

### 字体Font
* 硬盘中的保存格式为: .ttf ... 字体通常是以簇为概念，所有大小之类的均为簇上的属性
* 类型：Font
* 描述：字体解码在内存中的数据存储，Font作为抽象一层，下面针对于簇存取每份大小的字体(比如TTF_Font*)
* 抽象实现：Font为基类，数据存储
* 具体实现：
  * TTF_Font*